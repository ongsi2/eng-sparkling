AI 웹 서비스 '딸각 스튜디오' 개발 기술 백서

1. 서론: AI 기반 개발(Vibe Coding) 방법론과 프로젝트 개요

본 기술 백서는 AI 이미지 생성 웹 서비스 '딸각 스튜디오'의 아키텍처 설계부터 구현, 배포 및 운영에 이르는 전 과정을 기술적으로 심층 분석한다. 이 프로젝트의 핵심은 '바이브 코딩(Vibe Coding)'이라 명명된 AI 주도 개발 방법론을 적용하여, 1인 개발자가 복잡한 SaaS(Software as a Service)를 효율적으로 구축하는 것의 실효성을 검증하는 데 있었다. 본 문서는 프로젝트의 기술적 구현 전 과정을 상세히 기록하여 그 성과와 과제를 공유하는 것을 목표로 한다.

프로젝트의 근간을 이루는 핵심 기술 스택은 다음과 같다.

* 개발 방법론: 바이브 코딩 (AI 코드 생성)
* 프레임워크: Next.js (TypeScript 기반)
* 백엔드 & 데이터베이스: Supabase (BaaS)
* 배포: Vercel
* 핵심 외부 서비스: Ideogram API (이미지 생성), Cloudflare R2 (파일 저장소), Toss Payments (결제)

이 기술 스택은 1인 개발자가 직면하는 리소스 제약을 극복하고 개발 속도를 극대화하기 위한 전략적 선택이었다. Next.js와 Vercel은 프론트엔드 개발과 배포의 복잡성을 추상화했으며, Supabase는 BaaS(Backend-as-a-Service)로서 백엔드 인프라 구축에 소요되는 시간을 획기적으로 단축시켰다. 외부 전문 API를 적극적으로 통합함으로써 핵심 비즈니스 로직 구현에만 집중할 수 있는 환경을 구축했다. 이 모든 과정은 정교한 프롬프트를 통해 AI의 코드 생성 능력을 활용하는 '바이브 코딩' 방법론으로 진행되어, 아이디어의 신속한 시장 검증을 가능하게 했다.

이제부터 프로젝트의 초기 환경 설정이라는 견고한 기반을 다지는 단계부터 각 아키텍처 구성 요소가 어떻게 설계되고 구현되었는지 구체적으로 분석해 나가겠다.


--------------------------------------------------------------------------------


2. 프로젝트 초기 설정 및 개발 환경 구축

모든 성공적인 프로젝트는 재현 가능하고 안정적인 개발 환경에서 시작된다. 초기 환경 설정은 전체 개발 프로세스의 효율성과 안정성을 좌우하는 핵심 단계로, 본 섹션에서는 Next.js 프레임워크 기반의 프로젝트 생성과 Git을 이용한 버전 관리 시스템 연동 과정을 분석한다. 이는 이후의 복잡한 기능 구현 과정에서 발생할 수 있는 잠재적 오류를 최소화하고, 협업과 자동화의 기반을 마련하는 첫 번째 아키텍처 결정이다.

Next.js 프로젝트 생성

개발의 시작점으로 npx create-next-app@latest 명령어를 사용하여 최신 버전의 Next.js 프로젝트를 생성했다. 프로젝트 폴더명은 잠재적인 운영체제 호환성 문제를 원천적으로 방지하기 위해 영문 소문자와 하이픈(-) 조합으로 명명했다. 프로젝트 생성 시 제공되는 옵션들은 표준적인 개발 환경을 보장하기 위해 모두 기본값(Default)으로 설정했다.

Git 버전 관리 연동

프로젝트 생성 직후, git init 명령어로 로컬 Git 리포지토리를 초기화하고 원격 GitHub 리포지토리와 연동했다. 이는 모든 코드 변경 이력을 체계적으로 추적하여 문제 발생 시 특정 시점으로의 롤백을 가능하게 하는 안전장치를 마련하는 필수 과정이다. 동시에 Vercel을 통한 CI/CD(지속적 통합/지속적 배포) 파이프라인의 전제 조건이 된다.

로컬 개발 서버 실행

npm run dev 명령어를 통해 로컬 개발 서버를 실행하며, Next.js가 제공하는 Hot Reloading 기능을 활용했다. 이 기능은 코드 변경 사항을 저장하는 즉시 웹 브라우저에 실시간으로 반영하여, 개발자가 수정 결과를 즉각적으로 확인하며 개발에 몰입할 수 있는 빠르고 직관적인 워크플로우를 제공한다.

이처럼 견고하고 표준화된 초기 설정은 이후 진행될 복잡한 기능 구현 단계의 안정성을 보장하는 초석이다. 잘 구축된 개발 환경은 개발자가 인프라의 세부 사항이 아닌 비즈니스 로직 구현이라는 본질에 집중할 수 있도록 지원한다.


--------------------------------------------------------------------------------


3. 프론트엔드 구현: AI를 활용한 랜딩 페이지 제작

사용자와의 첫 접점인 랜딩 페이지는 서비스의 가치를 전달하는 핵심적인 역할을 수행한다. 이 아키텍처적 과제를 해결하기 위해, '바이브 코딩' 방법론을 적용하여 정교하게 설계된 프롬프트를 통해 고품질의 UI 초안을 신속하게 생성함으로써 초기 개발 시간을 획기적으로 단축했다.

AI 생성을 위한 구조화된 프롬프트 설계

AI가 디자인 의도를 명확하게 이해하고 고품질의 코드를 생성하도록 유도하기 위해, 랜딩 페이지를 6개의 논리적 영역으로 구조화한 프롬프트를 설계했다.

1. 헤더 (Header): 로고, 내비게이션 메뉴, '시작하기' 버튼의 레이아웃과 구성을 명시.
2. 히어로 (Hero): 서비스의 핵심 가치를 전달하는 제목과 부제를 정의.
3. 이미지 생성 인터페이스: 사용자가 프롬프트를 입력하고 이미지를 생성하는 핵심 UI 요소 배치.
4. 샘플 갤러리: 서비스의 이미지 생성 품질을 직관적으로 보여주는 예시 이미지 갤러리.
5. CTA (Call to Action): 사용자의 회원가입 및 서비스 이용을 유도하는 섹션.
6. 푸터 (Footer): 회사 정보, 약관 등 하단 정보 영역.

각 영역에 포함될 구성 요소, 텍스트, 레이아웃을 구체적으로 명시한 이 프롬프트는 AI에게 명확한 '설계도'를 제공하여, 수정이 거의 필요 없는 수준의 초기 코드를 생성하는 데 결정적인 역할을 했다.

이미지 리소스 관리 및 최적화

AI가 생성한 UI 템플릿에 실제 이미지를 반영하는 과정에서는 체계적인 리소스 관리 및 최적화 전략을 적용했다.

* 구조화된 폴더 관리: Next.js의 public 폴더 내에 samples 폴더를, 그 하위에 man, woman, baby 등 카테고리별 폴더를 구성했다. 파일명을 original.webp, ex1.webp 등으로 규칙화함으로써, AI에게 이미지 교체나 수정을 지시할 때 모호함 없이 명확한 커뮤니케이션이 가능하도록 설계했다.
* WebP 형식을 통한 최적화: 모든 이미지는 PNG/JPG 대신 WebP 형식을 채택했다. WebP는 시각적 품질 저하를 최소화하면서 파일 용량을 최대 1/10까지 감소시킬 수 있는 우수한 압축률을 제공한다. 이는 사용자의 초기 페이지 로딩 속도(Time-to-Interactive)를 개선하고 데이터 전송 비용을 절감하는 핵심적인 최적화 전략이다.
* 개발 환경 UI 오류 해결: 개발 서버의 Hot Reloading 과정에서 UI가 비정상적으로 표시되는 문제가 간혹 발생했다. 이때 브라우저 개발자 도구의 Application > Storage > Clear site data 기능을 사용하여 캐시, 쿠키, 서비스 워커 등 모든 사이트 데이터를 완전히 초기화하는 것이 가장 빠르고 효과적인 해결책임을 확인했다.

AI를 통한 UI 구현은 체계적인 리소스 관리 전략과 결합될 때 그 효과가 극대화된다. 정적인 랜딩 페이지가 신속하게 완성됨에 따라, 이제 서비스의 핵심 가치인 동적 기능을 추가하는 다음 단계로 나아갈 준비가 완료되었다.


--------------------------------------------------------------------------------


4. 핵심 기능 구현: 외부 AI API 연동

'딸각 스튜디오'의 핵심 가치 제안은 AI 이미지 생성 기능에 있으며, 이는 외부 전문 서비스인 Ideogram API를 연동하여 구현되었다. 이 과정은 단순한 기능 연결을 넘어, AI 주도 개발 환경에서 외부 시스템과의 연동 정확성과 안정성을 확보하기 위한 아키텍처적 접근이 요구되는 중요한 과제였다.

Ideogram API 선택 배경

다양한 이미지 생성 AI 서비스 중 Ideogram을 선택한 결정적 이유는 **'캐릭터의 얼굴을 유지하면서 다른 부분만 변경하는 기능'**이 당시 타 서비스 대비 독보적인 성능을 보였기 때문이다. 이는 서비스의 핵심 차별점으로 작용할 수 있는 강력한 기술적 우위였다.

AI 연동 정확도 향상을 위한 아키텍처 패턴

AI에게 외부 API 연동을 지시할 때 발생할 수 있는 코드의 부정확성을 최소화하기 위해, 외부 의존성을 내부화하는 전략적 패턴을 적용했다.

공식 문서를 로컬 컨텍스트로 변환하여 제공 Ideogram의 공식 API 연동 가이드 웹 페이지 URL을 AI에 직접 제공하는 대신, 해당 페이지의 내용을 마크다운(.md) 파일로 다운로드하여 프로젝트 폴더 내에 포함시켰다. 이후 AI에게 코드를 생성하도록 지시할 때, 이 로컬 파일을 직접 참조하도록 명시했다. 이 방식은 변경 가능성이 있는 불안정한 외부 의존성(URL)을 로컬의 정적이고 검증 가능한 컨텍스트로 변환한다. 이를 통해 AI가 항상 검증된 최신 정보를 기반으로 코드를 생성하도록 보장하여, 연동의 결정성과 정확도를 비약적으로 향상시켰다.

민감 정보의 안전한 관리

API 키와 같은 민감 정보는 코드에 하드코딩하는 대신, .env.local 파일에 환경 변수로 저장했다. 이 파일은 .gitignore에 등록하여 Git 버전 관리에서 제외함으로써, 소스 코드가 외부에 노출되더라도 키가 유출되지 않도록 하는 보안 모범 사례를 철저히 준수했다.

또한, API 요청 후 응답을 기다리는 동안 사용자 경험(UX) 저하를 방지하기 위해 '로딩 스피너'와 같은 시각적 피드백 요소를 추가했다. 이처럼 핵심 기능이 로컬 환경에서 성공적으로 구현되었으므로, 이제 전 세계 사용자들이 접근할 수 있도록 서비스를 배포하는 단계로 이행한다.


--------------------------------------------------------------------------------


5. 배포 및 도메인 연동 아키텍처

로컬 환경에서 개발된 웹 애플리케이션을 전 세계 사용자가 안정적으로 접근할 수 있는 프로덕션 환경에 배포하는 것은 프로젝트 성공의 필수 조건이다. 본 프로젝트에서는 Vercel과 Cloudflare를 연동하여, 빠르고 안정적이며 완전 자동화된 CI/CD(지속적 통합/지속적 배포) 및 DNS 아키텍처를 구축했다.

Vercel을 통한 자동화된 배포

Vercel은 Next.js 개발사가 직접 운영하는 배포 플랫폼으로, GitHub와의 긴밀한 통합을 제공한다. Vercel 대시보드에서 GitHub 리포지토리를 임포트하고 'Deploy' 버튼을 클릭하는 것만으로 배포가 완료된다. 이 아키텍처는 개발자가 인프라 관리의 복잡성에서 벗어나 코드 개발에만 집중할 수 있게 하며, GitHub 리포지토리에 코드를 푸시(push)할 때마다 자동으로 새로운 버전을 빌드하고 배포하는 CI/CD 파이프라인을 구축한다.

Cloudflare를 통한 DNS 관리

도메인은 hosting.kr과 같은 등록 기관에서 구매했으며, DNS(Domain Name System) 관리는 Cloudflare를 통해 수행했다. 이는 다음과 같은 전략적 이유에 기반한다.

* 안정성과 성능: 전 세계에 분산된 글로벌 네트워크를 통해 안정적이고 빠른 DNS 조회를 보장한다.
* 비용 효율성: 무료 플랜으로도 강력한 DNS 관리 기능을 제공하며, 향후 연동할 R2 스토리지와의 비용 시너지가 뛰어나다.
* 확장성: 이미지 영구 저장을 위해 사용할 Cloudflare R2 오브젝트 스토리지와의 통합을 염두에 둔 아키텍처적 선택이다.

도메인 연결 프로세스

1. 도메인 등록 기관(hosting.kr)에서 구매한 도메인의 네임 서버(Name Server)를 Cloudflare가 제공하는 주소로 변경한다.
2. Cloudflare DNS 설정 페이지에서 Vercel이 요구하는 A 레코드와 CNAME 레코드를 등록한다. 이때 Cloudflare의 프록시 설정은 반드시 비활성화해야 한다. Vercel은 자체적인 엣지 네트워크, SSL 인증서 발급(Let's Encrypt), 트래픽 라우팅을 수행한다. Cloudflare 프록시를 활성화하면 '이중 프록시(Double Proxy)' 상황이 발생하여 잠재적인 SSL 인증서 충돌, 불필요한 레이턴시 증가, 문제 해결의 복잡성을 야기할 수 있다. 프록시를 비활성화함으로써 Vercel 플랫폼이 의도된 대로 간섭 없이 동작하도록 보장한다.
3. Vercel 프로젝트의 도메인 설정에서 구매한 도메인을 추가하면, DNS 레코드 확인 후 자동으로 연결이 완료된다.

이 아키텍처를 통해 견고하고 자동화된 배포 환경이 마련되었다. 다음 단계는 사용자 관리 및 데이터 저장을 위한 백엔드 시스템을 구축하는 것이다.


--------------------------------------------------------------------------------


6. 백엔드 및 데이터베이스 구축: Supabase 활용

현대 웹 서비스에서 사용자 인증과 데이터 관리는 필수적인 백엔드 기능이다. 이 아키텍처적 요구사항을 해결하기 위해 BaaS(Backend-as-a-Service) 솔루션인 Supabase를 채택했다. 이는 1인 개발자가 복잡한 백엔드 인프라를 직접 구축하는 대신, 핵심 비즈니스 로직 개발에 집중할 수 있도록 하는 효율적인 전략이다.

사용자 인증 전략: 소셜 로그인 우선 아키텍처

초기 기획 단계에서, 이메일 가입 방식은 구현 복잡성(비밀번호 찾기, 이메일 인증 등) 대비 실제 사용률이 낮다는 데이터 기반 판단을 내렸다. 반면 구글/카카오와 같은 소셜 로그인은 사용자에게 편리한 경험을 제공하고 개발 리소스를 절감시킨다. 따라서 소셜 로그인을 우선적으로 구현하기로 결정했다. 또한, UX 측면을 고려하여 별도의 로그인 페이지로 리디렉션하는 대신, 현재 화면 위에 모달(Modal) 팝업 형태로 로그인 창을 표시하여 사용자 컨텍스트가 유지되도록 설계했다.

Supabase의 역할

Supabase는 PostgreSQL 데이터베이스를 기반으로 인증, 실시간 데이터 동기화 등 다양한 백엔드 기능을 API 형태로 제공한다. 이를 통해 개발자는 서버 코드 작성 없이 프론트엔드에서 직접 데이터베이스와 상호작용할 수 있어 개발 속도를 비약적으로 향상시킬 수 있었다.

데이터베이스 스키마 설계 원칙

사용자 정보 관리를 위해 Supabase의 공식 권장 사항에 기반한 아키텍처를 채택했다.

Supabase가 기본 제공하는 auth.users 테이블을 직접 수정하는 대신, 별도의 profiles 테이블을 생성하는 패턴을 적용했다. 신규 사용자가 가입하면, auth.users 테이블의 id를 외래 키(Foreign Key)로 참조하여 profiles 테이블에 해당 사용자의 상세 정보(역할, 크레딧 등)를 저장한다. 이 설계는 애플리케이션의 사용자 데이터 모델을 BaaS 제공자의 인증 스키마로부터 **디커플링(Decoupling)**하는 중요한 아키텍처적 이점을 가진다. 이를 통해 향후 스키마 확장에 유연하게 대처하고 시스템의 종속성을 낮출 수 있다.

SQL 마이그레이션을 통한 스키마 관리

AI에게 필요한 테이블 구조(예: 'admin'과 'user' 역할을 구분하는 role 컬럼)를 명시하여 SQL 코드를 생성하도록 지시했다. 생성된 SQL 코드는 Supabase 대시보드의 'SQL Editor'에서 직접 실행하여 테이블 스키마를 변경했다. 이 과정에서 실행된 모든 SQL 명령어는 프로젝트 내에 마이그레이션 파일(supabase/migrations/...)로 저장하여, 데이터베이스 스키마의 변경 이력을 체계적이고 재현 가능하게 관리했다.

사용자 관리 시스템의 기반이 마련되었으므로, 이제 사용자가 생성하는 핵심 데이터를 영구적으로 보관할 저장소를 구축하는 과정으로 넘어간다.


--------------------------------------------------------------------------------


7. 영구 데이터 저장소 구축: Cloudflare R2 연동

사용자가 생성한 디지털 자산(AI 이미지)을 안정적이고 영구적으로 보관하기 위해서는 전용 오브젝트 스토리지가 필수적이다. Ideogram API는 생성된 이미지를 일정 기간만 보관하는 임시 URL로 제공하므로, 이를 영구 자산으로 전환하기 위한 데이터 파이프라인 아키텍처 설계가 필요했다. Cloudflare R2는 S3 호환 API를 제공하며 egress 비용이 없어 이 문제의 최적 해결책으로 선택되었다.

이미지 처리 및 저장 워크플로우

사용자가 이미지 생성을 요청했을 때 데이터가 처리되는 전체 흐름은 다음과 같은 5단계 파이프라인으로 구성된다.

1. 생성 요청: 애플리케이션 서버(Vercel 서버리스 함수)가 Ideogram API를 호출하여 이미지 생성을 요청한다.
2. 임시 에셋 수신: Ideogram API는 생성된 이미지에 접근할 수 있는 임시 URL을 반환한다.
3. 에셋 다운로드: 서버는 반환된 임시 URL로부터 이미지 파일을 직접 다운로드한다.
4. 영구 저장소에 기록: 다운로드한 이미지 파일을 Cloudflare R2 버킷(Bucket)에 업로드하여 영구 저장한다.
5. 메타데이터 기록: 업로드가 완료되면, R2에 저장된 이미지의 영구 URL과 사용자 ID, 원본 프롬프트 등 관련 메타데이터를 Supabase의 generated_images 테이블에 기록한다.

Cloudflare R2 설정 및 연동

R2 연동을 위해 Cloudflare 대시보드에서 버킷을 생성하고, API 접근을 위한 토큰을 발급받았다. 이 과정에서 생성된 다음의 6가지 환경 변수는 Vercel 프로젝트에 안전하게 등록하여, 배포된 애플리케이션이 R2 스토리지에 접근할 수 있도록 권한을 부여했다.

* R2_ACCOUNT_ID
* R2_ACCESS_KEY_ID
* R2_SECRET_ACCESS_KEY
* R2_BUCKET_NAME
* R2_PUBLIC_DOMAIN
* NEXT_PUBLIC_APP_URL

'내 갤러리' 기능과 데이터 일관성

이 아키텍처를 기반으로 '내 갤러리' 페이지를 구현하여 사용자가 자신이 생성한 이미지를 조회하고 관리할 수 있도록 했다. 특히 이미지 삭제 기능은 여러 시스템에 분산된 데이터의 일관성을 유지하는 것이 매우 중요했다. 사용자가 삭제를 요청하면, 다음 세 가지 작업이 원자적(Atomic)으로 처리되도록 구현했다.

* 프론트엔드 UI에서 해당 이미지 제거
* Supabase generated_images 테이블에서 관련 레코드 삭제
* Cloudflare R2 버킷에서 실제 이미지 파일 삭제

서비스의 핵심 기능과 데이터 저장소 구축이 완료됨에 따라, 이제 서비스의 장기적인 지속 가능성을 확보하기 위한 수익화 모델을 설계하는 단계로 나아간다.


--------------------------------------------------------------------------------


8. 수익화 시스템 설계 및 구현: 크레딧 및 결제 연동

SaaS의 지속 가능성을 확보하기 위한 핵심은 효과적인 수익화 시스템이다. 본 프로젝트는 이미지 생성 횟수에 따라 차감되는 크레딧 기반 시스템을 채택했으며, 이를 위해 Toss Payments 결제 솔루션을 연동했다. 이 과정은 단순한 기능 구현을 넘어 법적, 회계적 요구사항을 충족하는 정교한 데이터 모델과 비즈니스 로직 설계가 요구되는 복잡한 과제였다.

크레딧 시스템 설계 요구사항

복잡한 시스템일수록 초기 요구사항 정의가 아키텍처의 안정성을 좌우한다. 크레딧 시스템 설계를 위해 다음과 같은 핵심 요구사항을 분석하고 정의했다.

* 법적 의무: 전자상거래법에 따라 사용자의 구매 내역은 최소 5년간 보관해야 한다.
* 고객 지원: 사용자의 크레딧 관련 문의에 대응하기 위해 모든 소진 내역을 추적할 수 있어야 한다.
* 회계 원칙: 먼저 구매한 크레딧이 먼저 소진되는 선입선출(First-In, First-Out, FIFO) 로직을 적용하여 회계적 정합성을 확보해야 한다.
* 정책 정의: 이미지 생성 1회당 소진되는 크레딧 양을 명확히 정의해야 한다.

데이터베이스 스키마 설계

위 요구사항을 시스템으로 구현하기 위해 다음과 같은 테이블을 포함하는 데이터베이스 스키마를 설계했다.

* pricing_plans: 판매할 요금제 정보(가격, 제공 크레딧)를 관리한다.
* payment_history: 사용자의 모든 결제 내역을 기록하여 5년 보관 의무를 준수한다.
* credit_usage_history: 이미지 생성 시 상세 소진 내역을 기록한다.
* profiles: 각 사용자의 현재 보유 크레딧 총량을 관리한다.

이때 payment_history와 credit_usage_history는 profiles 테이블을 외래 키로 참조하여 사용자별 데이터를 명확하게 연결했다. 반면 pricing_plans 테이블은 의도적으로 독립적인 엔티티로 설계했다. 요금 정책은 개별 사용자가 아닌 서비스 전체에 적용되는 글로벌 정책이기 때문에, 이러한 아키텍처적 분리는 데이터 모델의 논리적 명확성을 높인다.

Toss Payments 연동

Toss Payments의 상세한 공식 연동 가이드를 AI의 컨텍스트로 제공하여 결제 모듈을 구현했다. 개발 단계에서는 실제 비용이 발생하지 않는 테스트용 클라이언트 키와 시크릿 키를 활용하여 결제 및 환불 프로세스의 모든 엣지 케이스를 안전하게 검증했다.

이처럼 복잡한 시스템은 초기 설계 단계에서 모든 요구사항을 상세히 정의하고 이를 프롬프트에 반영하는 것이 아키텍처적 부채를 방지하고 개발 효율을 극대화하는 핵심 전략임을 확인했다. 이제 서비스 운영을 위한 내부 관리 도구를 구축할 차례이다.


--------------------------------------------------------------------------------


9. 운영 효율화를 위한 관리자 페이지 구축

서비스 출시는 끝이 아닌 시작이며, 효율적인 운영과 신속한 고객 지원을 위해 내부 관리자 페이지는 필수적인 전략적 자산이다. 관리자 페이지는 개발자가 데이터베이스에 직접 접근하는 위험을 최소화하면서 대부분의 운영 업무를 처리할 수 있게 하여 생산성과 보안을 동시에 향상시킨다.

관리자 페이지 핵심 기능 구성

'딸각 스튜디오'의 관리자 페이지는 다음과 같은 핵심 메뉴로 구성되었다.

* 대시보드: 일별/월별 매출, 신규 가입자 수 등 핵심 운영 지표(KPI)를 시각적으로 요약한다.
* 회원 관리: 특정 사용자의 정보를 조회하고 계정 상태를 관리한다.
* 결제 관리: 모든 결제 내역을 조회하고 필터링한다.
* 환불 관리: 사용자의 환불 요청을 확인하고 승인 또는 거절 처리를 수행한다.
* 플랜 관리: 데이터베이스를 직접 수정하지 않고 요금제의 가격, 제공 크레딧 등을 동적으로 변경한다.

관리자 권한 부여 및 접근 제어

관리자 계정은 Supabase의 profiles 테이블에서 특정 사용자의 role 컬럼 값을 수동으로 'admin'으로 변경하여 권한을 부여하는 방식으로 구현했다. 애플리케이션의 미들웨어는 페이지 접근 시 이 role 값을 확인하여 인가되지 않은 사용자의 접근을 차단한다.

RLS 정책 오류: '바이브 코딩'의 한계에 대한 사례 연구

관리자 페이지 개발 초기, 관리자가 일반 회원의 결제 데이터를 조회할 수 없는 문제가 발생했다. 이는 기능적 버그가 아닌, 보안 정책 구성의 누락에서 비롯된 문제였다. 원인은 Supabase의 행 수준 보안(Row-Level Security, RLS) 정책이 "사용자는 자신의 데이터만 조회할 수 있다"라고만 정의되어 있었기 때문이다.

이 사례는 '바이브 코딩'의 중요한 한계를 보여준다. AI는 명시적으로 지시된 기능적 코드는 능숙하게 생성하지만, 데이터 접근 권한과 같은 암묵적인 보안 컨텍스트를 추론하는 데는 한계가 있다.

해결책: "role이 'admin'인 사용자는 모든 사용자의 결제 데이터를 조회할 수 있다"는 새로운 RLS 정책을 SQL로 명시적으로 작성하여 추가했다. 이 과정에서 AI가 생성한 SQL 마이그레이션 파일을 실행하기 전, 인간 개발자가 데이터베이스 스키마와 보안 정책을 재검증하는 절차를 거쳐 안전하게 문제를 해결했다. 이 경험은 보안과 관련된 핵심 구성 요소에 대해서는 AI의 결과물을 맹신하지 않고, 인간의 아키텍처적 감독과 검증이 필수적임을 명확히 보여준다.

잘 구축된 관리자 페이지는 서비스의 '관제탑' 역할을 수행한다. 이제 서비스의 신뢰도를 한 단계 더 높이기 위한 보안 아키텍처 강화 조치를 분석한다.


--------------------------------------------------------------------------------


10. 보안 및 규정 준수 강화

사용자의 데이터를 안전하게 보호하고 관련 법규를 준수하는 것은 서비스 신뢰도의 근간이다. 본 프로젝트에서는 소프트 삭제, 체계적인 로그 관리, 그리고 핵심 개인정보 암호화라는 세 가지 축을 중심으로 보안 아키텍처를 강화하여 데이터의 기밀성, 무결성, 가용성을 보장하고자 했다.

10.1. 소프트 삭제(Soft Delete) 구현

소프트 삭제는 사용자가 회원 탈퇴를 요청했을 때, 관련 데이터를 데이터베이스에서 즉시 물리적으로 파기하는 대신 '삭제됨' 상태로 논리적으로만 전환하여 일정 기간 보관하는 아키텍처 패턴이다.

* 개념과 이점: 이 방식은 사용자의 실수로 인한 계정 복구 요청에 대응하고, 향후 발생할 수 있는 법적 분쟁 시 관련 데이터를 증빙 자료로 활용할 수 있는 가용성과 추적 가능성을 제공한다.
* 구현 방식: profiles 테이블에 deleted_at 타임스탬프 컬럼을 추가했다. 회원 탈퇴 요청 시, 해당 컬럼에 현재 시간을 기록한다. 애플리케이션 로직은 deleted_at 컬럼이 NULL이 아닌 사용자를 비활성화된 것으로 간주하여 시스템에서 배제한다.

10.2. 로그 시스템 구축 및 자동화

대한민국의 통신비밀보호법은 웹사이트 운영자가 사용자의 접속 기록(로그)을 최소 3개월간 보관하도록 의무화하고 있다.

* 로그 데이터 설계: user_activity_logs 테이블을 생성하여 사용자의 주요 활동(로그인, 로그아웃, 페이지 방문), 접속 IP 주소, 활동 시간 등을 기록하도록 설계했다.
* 자동 삭제 로직: 규정 준수와 데이터베이스 스토리지 효율화를 위해, Supabase의 pg_cron 확장 기능을 활성화했다. 90일이 경과한 로그 데이터를 매일 자동으로 삭제하는 스케줄된 작업을 등록하여, 수동 개입 없이 로그 데이터의 생명주기를 관리하는 프로세스를 자동화했다.

10.3. 개인정보 암호화 적용

데이터베이스 침해 사고 발생 시에도 사용자의 민감한 정보 유출을 방지하기 위해 핵심 개인정보를 암호화했다.

* 암호화 대상: profiles 테이블의 이메일, 이름, 아바타 URL과 user_activity_logs 테이블의 IP 주소를 암호화 대상으로 지정했다.
* 암호화 방식: 이 프로젝트는 데이터베이스 레벨 암호화가 아닌 애플리케이션 코드 레벨에서 AES-256-GCM 대칭키 암호화 방식을 적용했다. 이는 데이터베이스 기술에 대한 종속성을 제거하는 중요한 아키텍처적 결정이다. 약간의 애플리케이션 복잡성을 감수하는 대신, 향후 데이터베이스를 교체하더라도 암호화 로직을 그대로 유지할 수 있는 유연성과 이식성을 확보하는 전략적 트레이드오프이다.
* 복호화 로직: 데이터베이스에는 항상 암호화된 상태로 데이터가 저장된다. 운영 편의성을 위해, 인가된 관리자가 관리자 페이지에서 사용자 정보를 조회할 때만 서버 측에서 데이터를 복호화하여 표시하도록 구현했다. 이를 통해 강력한 보안과 운영 효율성 사이의 균형을 맞췄다.

이 모든 보안 시스템의 핵심은 암호화 키의 안전한 관리이다. 암호화 키는 .env 파일과 Vercel 환경 변수를 통해 소스 코드와 완전히 분리하여 철저하게 관리되었다.


--------------------------------------------------------------------------------


11. 결론: '바이브 코딩'을 통한 SaaS 개발의 성과와 미래

'딸각 스튜디오' 프로젝트는 '바이브 코딩'이라는 AI 주도 개발 방법론을 통해 1인 개발자가 아이디어 구상부터 수익화, 운영 시스템까지 복잡한 SaaS 개발 전 과정을 성공적으로 완수할 수 있음을 입증했다. Next.js, Supabase, Vercel, Cloudflare 등 현대적인 기술 스택을 전략적으로 조합하여, 인프라 관리의 부담을 최소화하고 개발 속도를 극대화하는 아키텍처를 구축했다.

'바이브 코딩' 방법론의 효과와 한계를 종합적으로 평가하면 다음과 같다.

* 강점: 정교한 프롬프트를 통해 초기 프로토타이핑 및 기능 구현 속도를 획기적으로 단축시켰다. 이는 1인 개발자나 비전문가의 시장 진입 장벽을 유의미하게 낮추는 잠재력을 보여준다.
* 과제: AI가 생성한 코드는 완벽하지 않으므로, 인간 개발자의 비판적 검증과 아키텍처적 감독이 필수적이다. 본 백서에서 다룬 구체적인 과제들은 다음과 같다.
    1. 암묵적 보안 컨텍스트의 부재: 9장에서 분석한 RLS 정책 누락 사례는 AI가 명시되지 않은 접근 제어 요구사항을 추론하는 데 한계가 있음을 보여준다.
    2. 복잡한 상태 관리의 어려움: 7장의 이미지 저장 파이프라인이나 8장의 크레딧 FIFO 로직처럼 여러 시스템에 걸친 복잡한 상태 관리는 AI가 단번에 완벽한 코드를 생성하기 어려운 영역이다.
    3. AI 생성 SQL의 검증 필요성: 8장과 9장에서 확인했듯이, 데이터베이스 스키마를 변경하는 AI 생성 SQL 마이그레이션 파일은 실행 전 반드시 재검증하는 프로세스가 수반되어야 한다.

이 프로젝트는 소프트웨어 개발 패러다임의 변화에 대한 중요한 시사점을 제공한다. 미래의 개발자는 단순히 코드를 작성하는 역할을 넘어, 문제 해결을 위한 최적의 아키텍처를 설계하고, AI가 의도를 정확히 파악하도록 명확하게 소통하며, 그 결과물을 비판적으로 검증하고 통합하는 '아키텍트'이자 'AI 협업 전문가'의 역할로 진화할 것이다.

결론적으로, 데이터베이스 구조, 보안 원칙, 시스템 디자인과 같은 근본적인 컴퓨터 과학 지식의 중요성은 오히려 더욱 커졌다. AI는 강력한 도구이지만, 그 도구를 효과적으로 활용하여 견고하고 안정적인 시스템을 구축하는 능력은 결국 개발자의 깊이 있는 이해와 통찰력에 달려 있다. 미래 개발자의 핵심 역량은 코딩 능력 그 자체를 넘어, AI를 지렛대로 삼아 더 큰 아키텍처적 가치를 창출하는 능력이 될 것이다.
